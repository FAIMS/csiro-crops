<?xml version="1.0" ?>
<!--@POSTPROC: ./postproc.sh-->
<module>

<Main f="nodata">
  <Main>
    <Record_Field t="button" l="Field"/>
    <Logout t="button" l="Login"/>
  </Main>
  <search>
    <!--Searching has been modified to include only local records using a-->
    <!--combination of code in this file (ctrl+f: "LOCAL RECORDS") and-->
    <!--@POSTPROC.-->
  </search>
</Main>

<Login f="nodata">
  <Login>
    <User_ID t="dropdown" f="user">
      <!--Users are disallowed from logging in with a blank dropdown via-->
      <!--@POSTPROC.-->
    </User_ID>
    <Login t="button" l="Main"/>
  </Login>
</Login>

<Field>
  <Field>
    <Crop_Type f="id nocertainty">
      <str>
        <!--TODO:-->
        <!--  BRIAN:-->
        <!--    Crop, show annotation if not null, year-->
        <!--    So we can do Wheat 2016-->
        <!--    so if annotation, show it with ": annotation"-->
        <!--    {{if and($1, not($3)) then "$1 "}}{{if and($1, $3) then "$3 "}} let's see what that does-->
        <!--    basically, if there's no freetext, write vocab-->
        <!--    if there's freetext, write freetext-->
        <fmt>{{if and($1, not($3)) then "$1 "}}{{if and($1, $3) then "$3 "}}</fmt>
      </str>
      <opts>
        <opt>Wheat</opt>
        <opt>Barley</opt>
        <opt>Oats</opt>
        <opt>Tricicale</opt>
        <opt>Rye</opt>
        <opt>Canola</opt>
        <opt>Lupins</opt>
        <opt>Field Peas</opt>
        <opt>Chickpeas</opt>
        <opt>Fababeans</opt>
        <opt>Lentils</opt>
        <opt>Vetch</opt>
        <opt>Sunflower</opt>
        <opt>Sorghum</opt>
        <opt>Cotton</opt>
        <opt>Rice</opt>
        <opt>Sown legume pasture</opt>
        <opt>Volunteer pasture</opt>
        <opt>Other</opt>
      </opts>
    </Crop_Type>
    <Year b="decimal" f="id nocertainty"/>
    <Month_of_Sowing b="date" f="nocertainty"/>
    <Month_of_Harvest t="radio" f="nocertainty">
      <opts>
        <opt>March</opt>
        <opt>April</opt>
        <opt>May</opt>
      </opts>
    </Month_of_Harvest>
    <Enterprise t="radio" f="nocertainty">
      <opts>
        <opt>Yes</opt>
        <opt>No</opt>
      </opts>
    </Enterprise>
    <Photo t="camera" f="nocertainty"/>
    <Notes f="nocertainty"/>
  </Field>
  <Location>
    <Record_Centre_of_Paddock t="button"/>
    <Centre_of_Paddock t="input" f="readonly nocertainty"/>
    <Hr_Tag t="webview" f="nolabel"/>
    <cols>
      <col>
        <Record_NW_Corner_of_Paddock t="button"/>
        <Record_NE_Corner_of_Paddock t="button"/>
      </col>
      <col>
        <Record_SW_Corner_of_Paddock t="button"/>
        <Record_SE_Corner_of_Paddock t="button"/>
      </col>
    </cols>
    <Corners_of_Paddock t="input" b="string" f="readonly nocertainty"/>
  </Location>
</Field>

<logic><![CDATA[
/******************************* LOCAL RECORDS ********************************/
/* Keeps the list of records user-specific and improves performance.          */
/*                                                                            */
/* TODO: The search query doesn't filter results properly yet.                */
/* TODO: Ensure that the formatString is correctly applied in search results. */
/******************************************************************************/
  // Create a table in the database for the user-specific records if one doesn't
  // exist yet.
  String q = "";
  q += "CREATE TABLE IF NOT EXISTS localRecord ";
  q += "(uuid text primary key, response text);";
  fetchOne(q);

  // The saveFieldCallback and deleteFieldCallback functions are set as a
  // callback to saveTabGroup("Field") and duplicateField() via the @POSTPROC
  // script.
  saveFieldCallback() {
    // Determine/set currentUuid and archEntType
    String tabgroup    = "Field";
    String archEntType = tabgroup.replaceAll("_", " ");
    String currentUuid = getUuid(tabgroup);

    // Make and execute query to update/insert local record data
    String q = "";
    q += "REPLACE INTO localRecord(uuid, response) ";
    q += "  SELECT uuid, response ";
    q += "  FROM latestNonDeletedArchEntFormattedIdentifiers ";
    q += "  WHERE uuid = '%s'; ";
    q  = q.replaceFirst("%s", currentUuid);
    fetchOne(q);
  }

  deleteFieldCallback() {
    // Determine/set currentUuid and archEntType
    String tabgroup    = "Field";
    String archEntType = tabgroup.replaceAll("_", " ");
    String currentUuid = getUuid(tabgroup);

    // Make and execute deletion query
    String q = "";
    q += "DELETE FROM localRecord ";
    q += "WHERE uuid='%s';";
    q  = q.replaceFirst("%s", currentUuid);
    fetchOne(q);
  }

/**************************** USERNAME PERSISTENCE ****************************/
/* Remembers username selected from previous session and automatically logs   */
/* the user in with it subsequent sessions.                                   */
/*                                                                            */
/* TODO: Check for two or more users that their search results are unique.    */
/*                                                                            */
/* Requirement source: Email, "Fwd: my contact details"                       */
/******************************************************************************/
  addOnEvent("Main",              "load",  "acquireUser()");
  addOnEvent("Login/Login/Login", "click", "savePreviousUser()");

  // Load the last user from localSettings if it exists. Otherwise, redirect the
  // user to the Login tab group.
  acquireUser() {
    String gotoTabGroup = "Login";
    String key = "Login/Login/User_ID";
    String q = "SELECT value FROM localSettings WHERE key = '" + key + "';";

    // `dialog` is a global defined by the autogenerator
    dialog = showBusy("Loading module", "please wait...");
    fetchOne(q, new FetchCallback() {
      onFetch(result) {
        if (isNull(result)) {
          showTabGroup(gotoTabGroup);
        } else {
          String userVocabId = result.get(0);
          selectUser(userVocabId);
        }

        dialog.dismiss();
      }
    });
  }

  savePreviousUser() {
    String key = "Login/Login/User_ID";
    String val = getFieldValue(key);
    insertIntoLocalSettings(key, val);
  }

  selectUser (String userVocabId) {
    String userQ = "SELECT userid,fname,lname,email FROM user " +
                   "WHERE  userid='" + userVocabId + "';";
    FetchCallback callback = new FetchCallback() {
      onFetch(result) {
        user = new User(
              result.get(0),
              result.get(1),
              result.get(2),
              result.get(3)
        );
        setUser(user);
        username = result.get(1) + " " + result.get(2);
      }
    };

    fetchOne(userQ, callback);
  }

/************************ SAVING POSITIONS TO ARCHENT *************************/
/* Requirement source: Email, "Fwd: my contact details"                       */
/******************************************************************************/
  String c = "click"; // I'm obsessive about an 80-character limit on line width
  addOnEvent("Field/Location/Record_Centre_of_Paddock",    c, "saveCentre()");
  addOnEvent("Field/Location/Record_NW_Corner_of_Paddock", c, "saveNwCorner()");
  addOnEvent("Field/Location/Record_NE_Corner_of_Paddock", c, "saveNeCorner()");
  addOnEvent("Field/Location/Record_SW_Corner_of_Paddock", c, "saveSwCorner()");
  addOnEvent("Field/Location/Record_SE_Corner_of_Paddock", c, "saveSeCorner()");

  addOnEvent("Main", "show", "initialiseGeometry()");

  initialiseGeometry() {
    global.centre   = null;
    global.nwCorner = null;
    global.neCorner = null;
    global.swCorner = null;
    global.seCorner = null;
  }

  makeMapPos() {
    String msgSuccess = "Point taken";
    String msgFail    = "No GPS signal is present";

    Object pos = getGPSPosition();
    if (pos == null) {
      showToast(msgFail);
      return null;
    }

    Double lat = pos.getLatitude();
    Double lon = pos.getLongitude();
    MapPos mapPos = new MapPos(lon, lat);

    showToast(msgSuccess);
    return mapPos;
  }

  saveCentre()   { centre   = makeMapPos(); saveGeometry("point"); }
  saveNwCorner() { nwCorner = makeMapPos(); saveGeometry("poly"); }
  saveNeCorner() { neCorner = makeMapPos(); saveGeometry("poly"); }
  saveSwCorner() { swCorner = makeMapPos(); saveGeometry("poly"); }
  saveSeCorner() { seCorner = makeMapPos(); saveGeometry("poly"); }

  saveGeometry(String geoType) {
    if (!geoType.equals("point") && !geoType.equals("poly")) {
      throw new Error();
    }

    // Check if the point and/or the polygon will be savable
    Boolean doSavePoint = true;
    Boolean doSavePoly  = true;
    doSavePoint = doSavePoint && (centre   != null);
    doSavePoly  = doSavePoly  && (nwCorner != null);
    doSavePoly  = doSavePoly  && (neCorner != null);
    doSavePoly  = doSavePoly  && (swCorner != null);
    doSavePoly  = doSavePoly  && (seCorner != null);

    if (geoType.equals("point") && !doSavePoint) return;
    if (geoType.equals("poly")  && !doSavePoly)  return;

    // Cheery message to show user once the entity is saved
    String msgSuccess = "Geometry saved";

    // Some references we might need to modify
    String refCentre  = "Field/Location/Centre_of_Paddock";
    String refCorners = "Field/Location/Corners_of_Paddock";

    // Determine/set currentUuid and archEntType
    String tabgroup    = "Field";
    String archEntType = tabgroup.replaceAll("_", " ");
    String currentUuid = getUuid(tabgroup);

    // Make geometry---a point (centre) and a polygon (corners)
    List mapPoses = new ArrayList();
    mapPoses.add(nwCorner);
    mapPoses.add(neCorner);
    mapPoses.add(swCorner);
    mapPoses.add(seCorner);

    Point   pt   = null; PointStyle   ptS   = null;
    Polygon pgon = null; PolygonStyle pgonS = null;
    if (doSavePoint) { pt   = new Point  (centre,   null, ptS, null);   }
    if (doSavePoly)  { pgon = new Polygon(mapPoses, null, pgonS, null); }

    // Put geometry in a list
    ArrayList geoList = new ArrayList();
    if (doSavePoint) geoList.add(pt);
    if (doSavePoly)  geoList.add(pgon);

    // Prepare to save point to archEnt, then attempt to save archEnt. Upon a
    // successful save, update the fields displayed to the user.
    SaveCallback callback = new SaveCallback() {
        onSave(uuid, newRecord) {
          setUuid(tabgroup, uuid);
          saveFieldCallback();

          // toString() doesn't work for Polygons (`pgon`) for some reason
          if (doSavePoint) setFieldValue(refCentre,  pt.  toString());
          if (doSavePoly)  setFieldValue(refCorners, pgon.getVertexList() + "");

          showToast(msgSuccess);
        }
    };
    saveArchEnt(currentUuid, archEntType, geoList, null, callback);
  }

/************************ DRAW A PRETTY HR TAG IN HTML ************************/
  String ref  = "Field/Location/Hr_Tag";
  String html = "<hr/>";
  populateWebViewHtml(ref, html);
]]></logic>

</module>
